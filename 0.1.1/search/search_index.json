{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Py StepChain \ud83e\udea2","text":"<p>Composable step orchestrator for Python. Write clean, declarative pipelines for synchronous and asynchronous workflows \u2014 with retries, validation, logging, and hooks \u2014 all in a tiny, dependency-free package.</p> <ul> <li>\ud83d\udd12 Safe \u2014 retries, validation hooks, deadlines, error classes  </li> <li>\ud83d\udcca Transparent \u2014 precompiled logging, redaction, before/after hooks  </li> <li>\u26a1 Fast \u2014 near-zero runtime overhead, tiny dependency footprint (great for Lambdas &amp; microservices)  </li> <li>\ud83e\udde9 Universal \u2014 works in basic Python, FastAPI/asyncio, or inside your ETL jobs </li> </ul> <p>\ud83d\udc49 Start with Getting Started.</p>"},{"location":"comparison/","title":"Why not Airflow/Prefect/dbt/etc?","text":"<p>Those are heavy DAG engines for distributed orchestration.</p> <p>StepChain is for the inner loop: inside your function, microservice, or Lambda. It complements those tools, not replaces them.</p> <p>Use StepChain when you want: - Minimal dependencies and tiny cold start - Functional composition and fast unit tests - Inline retries, deadlines, hooks, and logging \u2014 without a platform</p>"},{"location":"features/","title":"Features","text":"<ul> <li>\u2705 Sync + Async APIs</li> <li>\u2705 Retries with backoff + jitter (deadline-aware)</li> <li>\u2705 Validation hooks per step</li> <li>\u2705 Logging templates with <code>{dotted.refs}</code> and JSON serialization</li> <li>\u2705 Before/After hooks for metrics and tracing</li> <li>\u2705 Context redaction for secrets</li> <li>\u2705 Strict mode: unresolved refs cause errors</li> <li>\u2705 100% type hints (mypy-friendly)</li> <li>\u2705 Dependency-free (stdlib only)</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install","title":"Install","text":"<pre><code>pip install py-stepchain\n</code></pre>"},{"location":"getting-started/#usage-examples","title":"Usage &amp; Examples","text":"<p>Short links to real, runnable examples in the repo:</p>"},{"location":"getting-started/#basic-sync-etl","title":"Basic sync ETL","text":"<pre><code># examples/basic_sync.py\nimport logging\nfrom stepchain import Chain, ValidationFailedError, StepFailedError\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\n\nSOURCE = [\n    {\"id\": 1, \"name\": \"alice\", \"active\": True},\n    {\"id\": 2, \"name\": \"bob\", \"active\": False},\n    {\"id\": 3, \"name\": \"carrie\", \"active\": True},\n]\n\n\ndef extract():\n    return SOURCE\n\n\ndef transform(rows):\n    return [{\"id\": r[\"id\"], \"name\": r[\"name\"].upper()} for r in rows if r[\"active\"]]\n\n\nTARGET = []\ncalls = {\"load\": 0}\n\n\ndef load(rows):\n    calls[\"load\"] += 1\n    if calls[\"load\"] == 1:\n        # force a retry once\n        raise RuntimeError(\"transient sink issue\")\n    TARGET.extend(rows)\n    return {\"loaded\": len(rows)}\n\n\ndef validate_non_empty(load_result):\n    if not load_result or not load_result.get(\"loaded\"):\n        raise ValueError(\"no rows loaded\")\n\n\ndef redact(msg: str) -&gt; str:\n    # example: mask secrets if any appear in logs\n    return msg.replace(\"SECRET\", \"****\")\n\n\nif __name__ == \"__main__\":\n    try:\n        ctx = (\n            Chain(redact=redact, strict=True)\n            .next(extract, out=\"raw\", log_fmt=\"raw_n={raw.__len__}\")\n            .next(transform, out=\"clean\", args=[\"raw\"], log_fmt=\"clean_n={clean.__len__}\")\n            .next(\n                load,\n                out=\"loadres\",\n                args=[\"clean\"],\n                retries=1,\n                retry_on=(RuntimeError,),\n                backoff=0.0,\n                max_backoff=0.0,\n                log_fmt=\"loaded={loadres.loaded}\",\n            )\n            .next(\n                lambda r: r[\"loaded\"],\n                out=\"count\",\n                args=[\"loadres\"],\n                log_fmt=\"count={count}\",\n            )\n            .run()\n        )\n        print(\"pipeline ok:\", ctx[\"count\"], \"rows loaded; target:\", TARGET)\n    except ValidationFailedError as e:\n        print(\"validation error:\", e)\n    except StepFailedError as e:\n        print(\"step failed:\", e)\n\n</code></pre>"},{"location":"getting-started/#basic-async-etl","title":"Basic async ETL","text":"<pre><code># examples/basic_async.py\nimport asyncio\nimport logging\nfrom stepchain.chain.async_chain import AsyncChain\nfrom stepchain.exceptions import ValidationFailedError, StepFailedError\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\n\nSOURCE = [\n    {\"id\": 10, \"name\": \"dave\", \"active\": True},\n    {\"id\": 11, \"name\": \"ellen\", \"active\": True},\n    {\"id\": 12, \"name\": \"frank\", \"active\": False},\n]\n\n\nasync def extract():\n    return list(SOURCE)\n\n\nasync def transform(rows):\n    return [{\"id\": r[\"id\"], \"name\": r[\"name\"].title()} for r in rows if r[\"active\"]]\n\n\ncalls = {\"n\": 0}\n\n\nasync def load(rows):\n    calls[\"n\"] += 1\n    if calls[\"n\"] == 1:\n        raise RuntimeError(\"flaky sink\")\n    return {\"loaded\": len(rows), \"rows\": rows}\n\n\ndef validate(res):\n    if not res.get(\"loaded\"):\n        raise ValueError(\"no rows loaded\")\n\n\nasync def main():\n    try:\n        ctx = await (\n            AsyncChain(jitter=False)  # deterministic; set backoff=0 to avoid sleeping\n            .next(extract, out=\"raw\", log_fmt=\"raw_n={raw.__len__}\")\n            .next(transform, out=\"clean\", args=[\"raw\"], log_fmt=\"clean_n={clean.__len__}\")\n            .next(\n                load,\n                out=\"loadres\",\n                args=[\"clean\"],\n                retries=1,\n                retry_on=(RuntimeError,),\n                backoff=0.0,\n                max_backoff=0.0,\n                log_fmt=\"loaded={loadres.loaded}\",\n            )\n            .run()\n        )\n        print(\"pipeline ok:\", ctx[\"loadres\"][\"loaded\"], \"rows:\", ctx[\"loadres\"][\"rows\"])\n    except ValidationFailedError as e:\n        print(\"validation error:\", e)\n    except StepFailedError as e:\n        print(\"step failed:\", e)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n</code></pre>"},{"location":"getting-started/#fastapi-sync-etl","title":"FastAPI sync ETL","text":"<pre><code># examples/fastapi_sync.py\nfrom fastapi import FastAPI\nfrom stepchain import Chain\n\napp = FastAPI(title=\"Stepchain Sync API\")\n\n\ndef extract_users():\n    return [\n        {\"id\": 1, \"name\": \"alice\", \"active\": True},\n        {\"id\": 2, \"name\": \"bob\", \"active\": False},\n        {\"id\": 3, \"name\": \"carrie\", \"active\": True},\n    ]\n\n\ndef transform_active(rows):\n    return [{\"id\": r[\"id\"], \"name\": r[\"name\"].upper()} for r in rows if r[\"active\"]]\n\n\ndef save(rows):\n    # pretend DB insert; just echo back\n    return {\"inserted\": len(rows), \"rows\": rows}\n\n\n@app.get(\"/sync/etl\")\ndef sync_etl():\n    ctx = (\n        Chain(strict=True)\n        .next(extract_users, out=\"raw\", log_fmt=\"raw={raw.__len__}\")\n        .next(transform_active, out=\"clean\", args=[\"raw\"], log_fmt=\"clean={clean.__len__}\")\n        .next(save, out=\"result\", args=[\"clean\"], log_fmt=\"inserted={result.inserted}\")\n        .run()\n    )\n    return ctx[\"result\"]\n\n</code></pre>"},{"location":"getting-started/#fastapi-async-etl","title":"FastAPI async ETL","text":"<pre><code># examples/fastapi_async.py\nfrom fastapi import FastAPI\nfrom stepchain.chain.async_chain import AsyncChain\n\napp = FastAPI(title=\"Stepchain Async API\")\n\n\nasync def fetch_items():\n    return [\n        {\"sku\": \"A1\", \"price\": 10.0, \"active\": True},\n        {\"sku\": \"B2\", \"price\": 0.0, \"active\": False},\n        {\"sku\": \"C3\", \"price\": 25.5, \"active\": True},\n    ]\n\n\nasync def to_invoice_lines(items):\n    return [\n        {\"sku\": x[\"sku\"], \"amount\": x[\"price\"]} for x in items if x[\"active\"] and x[\"price\"] &gt; 0\n    ]\n\n\nasync def post_invoice(lines):\n    # pretend call to billing service; return summary\n    return {\"lines\": len(lines), \"total\": sum(l[\"amount\"] for l in lines)}\n\n\n@app.get(\"/async/invoice\")\nasync def async_invoice():\n    ctx = await (\n        AsyncChain(jitter=False)\n        .next(fetch_items, out=\"items\", log_fmt=\"n_items={items.__len__}\")\n        .next(\n            to_invoice_lines,\n            out=\"lines\",\n            args=[\"items\"],\n            log_fmt=\"n_lines={lines.__len__}\",\n        )\n        .next(post_invoice, out=\"summary\", args=[\"lines\"], log_fmt=\"total={summary.total}\")\n        .run()\n    )\n    return ctx[\"summary\"]\n\n</code></pre> <p>These examples demonstrate context passing, retries, logging templates (<code>log_fmt</code>), and validation hooks.</p>"},{"location":"use-cases/","title":"Use Cases","text":"<ul> <li> <p>Data pipelines   ETL/ELT flows with retries, validation, and logging baked in.</p> </li> <li> <p>APIs &amp; async services   Orchestrate async calls (HTTP, DB, queues) with retries and deadlines.</p> </li> <li> <p>Business workflows   Chain validation \u2192 save \u2192 publish \u2192 notify in web apps.</p> </li> <li> <p>Serverless (AWS Lambda, GCP Cloud Functions)   Tiny cold-start friendly orchestrator (no heavy deps).</p> </li> <li> <p>Testing &amp; prototyping   Express multi-step flows declaratively, without external schedulers.</p> </li> </ul>"},{"location":"why-stepchain/","title":"Why StepChain?","text":"<p>Every real system has orchestration glue code:</p> <ul> <li>\u201cextract \u2192 transform \u2192 load\u201d ETL jobs  </li> <li>\u201cfetch \u2192 enrich \u2192 push\u201d API calls  </li> <li>\u201cvalidate \u2192 save \u2192 notify\u201d business workflows  </li> </ul> <p>Without structure, these pipelines quickly become: - \u274c Nested try/except spaghetti - \u274c Repeated logging boilerplate - \u274c Retry logic scattered everywhere - \u274c Hard to test, hard to extend  </p> <p>StepChain exists to fix that with a fluent, declarative API for pipelines\u2014clean, explicit, and production-ready.</p>"},{"location":"reference/async_chain/","title":"AsyncChain","text":"<p>Async orchestrator with the same semantics as <code>Chain</code>.</p> Differences <ul> <li>Awaits async steps; can also offload sync steps via <code>asyncio.to_thread</code>.</li> <li>Hooks can be async or sync.</li> <li>Uses <code>asyncio.sleep</code> during backoff.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, unresolved dotted refs raise <code>LookupError</code>. Otherwise resolve to <code>None</code>.</p> <code>False</code> <code>before_step</code> <code>HooksFn | None</code> <p>Optional hook (sync or async): <code>(step, context) -&gt; None | Awaitable</code>.</p> <code>None</code> <code>after_step</code> <code>HooksFn | None</code> <p>Optional hook (sync or async): <code>(step, context, result, elapsed) -&gt; None | Awaitable</code>.</p> <code>None</code> <code>on_retry</code> <code>HooksFn | None</code> <p>Optional hook (sync or async) for retry events.</p> <code>None</code> <code>redact</code> <code>Callable[[str], str] | None</code> <p>Optional log redactor.</p> <code>None</code> <code>deadline_fn</code> <code>Callable[[], float] | None</code> <p>Optional function returning remaining seconds.</p> <code>None</code> <code>safety_margin</code> <code>float</code> <p>Deadline buffer.</p> <code>0.25</code> <code>jitter</code> <code>bool</code> <p>Randomize sleep in backoff window.</p> <code>True</code> <code>allow_sync</code> <code>bool</code> <p>If True, synchronous steps are offloaded with <code>asyncio.to_thread</code>.</p> <code>True</code> See Also <p><code>Chain</code> for the synchronous variant.</p>"},{"location":"reference/async_chain/#stepchain.chain.async_chain.AsyncChain.put","title":"put","text":"<pre><code>put(key, value)\n</code></pre> <p>See <code>Chain.put</code>.</p>"},{"location":"reference/async_chain/#stepchain.chain.async_chain.AsyncChain.next","title":"next","text":"<pre><code>next(func, *, out, args=(), kwargs=None, name=None, retries=0, retry_on=(Exception,), backoff=1.5, max_backoff=10.0, log=None, log_fmt=None, validate=None)\n</code></pre> <p>See <code>Chain.next</code> (async compatible).</p>"},{"location":"reference/async_chain/#stepchain.chain.async_chain.AsyncChain.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Execute the async chain. See <code>Chain.run</code> for semantics.</p>"},{"location":"reference/chain/","title":"Chain","text":"<p>Composable, synchronous step orchestrator.</p> <p>A <code>Chain</code> lets you declare a sequence of steps that pass values via a mutable context dictionary. Each step can declare inputs by referencing context keys (including dotted paths), and write its output to a named key via <code>out</code>.</p> Features <ul> <li>Precompiled argument/keyword resolvers (fast, no reflection at runtime)</li> <li>Retries with backoff + optional jitter, deadline awareness</li> <li>Per-step validation hooks (fail-fast, not retried)</li> <li>Structured logging via templated <code>log_fmt</code> (with <code>{dotted.refs}</code>)</li> <li>Before/after hooks and message redaction</li> <li><code>strict</code> mode to error on unresolved references</li> </ul> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, unresolved dotted refs raise <code>LookupError</code>. Otherwise they resolve to <code>None</code>.</p> <code>False</code> <code>before_step</code> <code>HooksFn | None</code> <p>Optional hook called before each step: <code>(step, context) -&gt; None</code>.</p> <code>None</code> <code>after_step</code> <code>HooksFn | None</code> <p>Optional hook called after each step: <code>(step, context, result, elapsed) -&gt; None</code>.</p> <code>None</code> <code>on_retry</code> <code>HooksFn | None</code> <p>Optional hook called on retry: <code>(step, exc, attempt, next_delay) -&gt; None</code>.</p> <code>None</code> <code>redact</code> <code>Callable[[str], str] | None</code> <p>Optional function to scrub log lines before emission.</p> <code>None</code> <code>deadline_fn</code> <code>Callable[[], float] | None</code> <p>Optional function returning remaining seconds for deadline-aware retries.</p> <code>None</code> <code>safety_margin</code> <code>float</code> <p>Minimum seconds to keep as buffer before deadline when sleeping.</p> <code>0.25</code> <code>jitter</code> <code>bool</code> <p>If True, randomize delay within the backoff window.</p> <code>True</code> Example <p>from stepchain import Chain def add(a, b): return a + b ctx = (Chain().put(\"x\", 2).put(\"y\", 3) ...         .next(add, out=\"sum\", args=[\"x\",\"y\"]) ...         .run()) ctx[\"sum\"] 5</p>"},{"location":"reference/chain/#stepchain.chain.chain.Chain.context","title":"context  <code>property</code>","text":"<pre><code>context\n</code></pre> <p>Snapshot of the current context.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A shallow copy of the context dict (safe to inspect).</p>"},{"location":"reference/chain/#stepchain.chain.chain.Chain.put","title":"put","text":"<pre><code>put(key, value)\n</code></pre> <p>Preload a key/value into the chain context.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Context key.</p> required <code>value</code> <code>Any</code> <p>Value to store.</p> required <p>Returns:</p> Type Description <code>'Chain'</code> <p>Self (for fluent chaining).</p>"},{"location":"reference/chain/#stepchain.chain.chain.Chain.next","title":"next","text":"<pre><code>next(func, *, out, args=(), kwargs=None, name=None, retries=0, retry_on=(Exception,), backoff=1.5, max_backoff=10.0, log=None, log_fmt=None, validate=None)\n</code></pre> <p>Append a step to the chain.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Callable to execute. Its parameters are resolved from context using <code>args</code>/<code>kwargs</code>.</p> required <code>out</code> <code>str</code> <p>Context key to store the step's return value.</p> required <code>args</code> <code>Iterable[Any]</code> <p>Positional argument specs. Each item can be a literal or a context ref (e.g. <code>\"sum\"</code>, <code>\"obj.attr\"</code>).</p> <code>()</code> <code>kwargs</code> <code>Mapping[str, Any] | None</code> <p>Keyword argument specs using the same rules as <code>args</code>.</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Optional display name for logs; defaults to <code>out</code> or <code>func.__name__</code>.</p> <code>None</code> <code>retries</code> <code>int</code> <p>Max retries on exceptions matching <code>retry_on</code>. Validation errors never retry.</p> <code>0</code> <code>retry_on</code> <code>Tuple[Type[BaseException], ...]</code> <p>Tuple of exception types that are retryable.</p> <code>(Exception,)</code> <code>backoff</code> <code>float</code> <p>Initial delay multiplier between retries.</p> <code>1.5</code> <code>max_backoff</code> <code>float</code> <p>Max delay cap.</p> <code>10.0</code> <code>log</code> <code>Optional[Callable[[Mapping[str, Any], Any], None]]</code> <p>Optional callback <code>(ctx, result) -&gt; None</code> for custom logging.</p> <code>None</code> <code>log_fmt</code> <code>Optional[str]</code> <p>Log template with <code>{dotted.refs}</code>. Supports <code>{key.__len__}</code> and zero-arg callables (e.g., <code>model_dump</code>).</p> <code>None</code> <code>validate</code> <code>Optional[Callable[[Any], None]]</code> <p>Optional <code>(result) -&gt; None</code> that raises to mark invalid results.</p> <code>None</code> <p>Returns:</p> Type Description <code>'Chain'</code> <p>Self (for fluent chaining).</p>"},{"location":"reference/chain/#stepchain.chain.chain.Chain.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Execute the chain synchronously.</p> <p>The context is mutated in-place as steps run. If a step fails with a retryable error, backoff + jitter + deadline checks are applied. If the deadline is exceeded, a <code>StepFailedError</code> is raised. Validation failures raise <code>ValidationFailedError</code> immediately.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The final context dictionary.</p> <p>Raises:</p> Type Description <code>ValidationFailedError</code> <p>A step's <code>validate</code> hook failed.</p> <code>StepFailedError</code> <p>Retries exhausted or deadline exceeded.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>               Bases: <code>Exception</code></p> <p>Base error for stepchain.</p> <p>               Bases: <code>StepchainError</code></p> <p>Raised when a step fails after exhausting retries or a retry is prevented due to deadline.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>str</code> <p>Step name.</p> required <code>reason</code> <code>str</code> <p>Human-readable failure reason.</p> required <p>               Bases: <code>StepchainError</code></p> <p>Raised when a step's <code>validate</code> hook rejects the produced result.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>str</code> <p>Step name.</p> required <code>reason</code> <code>str</code> <p>Human-readable validation failure.</p> required"},{"location":"reference/support/","title":"Context &amp; Formatting","text":"<p>Resolve a dotted path against a mapping/object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_dotted({\"a\": {\"b\": 1}}, \"a.b\")\n1\n&gt;&gt;&gt; class X: pass\n&gt;&gt;&gt; x = X(); x.v = 3\n&gt;&gt;&gt; get_dotted({\"x\": x}, \"x.v\")\n3\n</code></pre> <p>Compile a reference spec into a resolver callable.</p> <ul> <li>Literals return as-is.</li> <li><code>\"key\"</code> fetches from context.</li> <li><code>\"key.inner.attr\"</code> traverses mappings/attributes.</li> <li>In <code>strict</code> mode, unresolved references raise <code>LookupError</code>.</li> </ul> <p>Returns:</p> Type Description <code>Callable[[Mapping[str, Any]], Any]</code> <p>A function <code>(ctx) -&gt; value</code> used at runtime to fetch the argument value.</p> <p>Vectorized <code>compile_ref</code> for kwargs specs.</p> <p>Precompile a logging template with <code>{dotted.refs}</code>.</p> Supported tokens <ul> <li><code>{key.path}</code>: read from context</li> <li><code>{result.path}</code>: read from current step result</li> <li><code>{key.__len__}</code>: length of the resolved value</li> <li>zero-arg callables (e.g. <code>{plan.model_dump}</code>)</li> <li>dict/list are JSON-serialized</li> </ul> <p>Returns:</p> Type Description <code>Callable[[Mapping[str, Any], Any], str] | None</code> <p>A renderer <code>(ctx, result) -&gt; str</code>, or <code>None</code> if <code>fmt</code> is falsy.</p> <p>Compatibility wrapper that calls the compiled renderer.</p>"}]}